\section{Related Work}

There are several research area relevant to our conversion.
Semantic modifiers~\cite{abramov2001standard} and universal resolving algorithm~\cite{abramov2002principles} may be used for inverse interpretation of first order functional programs.
They do not guarantee termination in general, which is reasonable, given that the problem is undecidable.

Logic and relational programming languages inherently support inverse computations, but they often come with significant overhead.
Reducing such overhead may be done with such techniques as partial evaluation, or partial deduction.
Applying these techniques to \mk has not yet done successfully, although some speed ups were achieved~\cite{EPTCS341.5}.

Functional logic programming languages such as \curry and \mercury translate their logic subsets into a general programming language.
\mercury uses a sophisticated system of modes along with mode analysis~\cite{overton2002constraint} which we plan to adapt to \mk as part of future work.
The search strategy in \mercury is not complete which limits its use for our application.

\curry has several compilers including the one whose target language is \haskell~\cite{brassel2011kics2}.
Although, \curry provides some flexibility in choosing the search strategy~\cite{hanus2012search}, it uses \lstinline{choice} to implement nondeterminism instead of unifications.

An earlier attempt at conversion of \mk into a functional program has been made.
It involved binding-time analysis to determine \lstinline{in/out} annotations of variables~\cite{verbitskaiabinding}.
It only works for directions which return finite answer streams which severely limits its applications.

There exist an automatic conversion from a subset of \ocaml into \ocanren~\cite{lozov2017typed}.
Coupling it with conversion from \mk back into \ocaml can be used to efficiently inverse computations.


