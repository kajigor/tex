\section{Examples of Translation}

A relation \lstinline{add$^o$ x y z} succeeds whenever \z is a sum of \x and \y.
An implementation of this relation which uses Peano numbers is shown in Listing~\ref{add}.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add}, caption={Addition relation}, captionpos=b, frame=tb]
let rec add$^o$ x y z = conde [
  (x === O /\ y === z);
  (fresh (x' z')
    (x === S x' /\
     z === S z' /\
     add$^o$ x' y z') ) ]
    \end{lstlisting}
  \end{minipage}
\end{figure}

One can run a relation in some \emph{direction} by passing it \emph{input} arguments.
For example, executing \lstinline{add$^o$ (S O) O z} finds the sum of the first two arguments and maps \lstinline{z} to the sum \lstinline{S O}.
We can also provide only the last argument: \lstinline{add$^o$ x y (S O)}.
This computes all pairs of Peano numbers \lstinline{(x, y)} which sum up to the given value \lstinline{z = S O} which are \lstinline{(O, S O)} and \lstinline{(S O, O)}.
Moreover, we can pass as input arguments not only \emph{ground terms} but terms which contain fresh variables, such as \lstinline{add$^o$ x (S y) z}.
Executing this relation finds all triples \lstinline{(x, y, z)} such that \lstinline{x + (y + 1) = z}.
Running in some directions can fail.
For example \lstinline{add$^o$ (S x) y O} may never succeed, since \lstinline{(1 + x) + y} can never be equal to \zero.

There exists a multitude of different directions for each relation.
In this paper we only consider directions in which input arguments are ground, i.e. do not contain any fresh variables, we will call them \emph{principal directions}.
We denote a principal direction by the name of a relation followed by specification of its arguments: in place of each argument we write either \lstinline{in} when the argument is input or \lstinline{out} if it is output.
There are $8$ principal directions for \lstinline{add$^o$ x y z}:
\begin{itemize}
  \item three directions with one input: \lstinline{add$^o$ in out out},

  \lstinline{add$^o$ out in out}, and \lstinline{add$^o$ out out in};
  \item three directions with two inputs: \lstinline{add$^o$ in in out},

  \lstinline{add$^o$ in out in}, \lstinline{add$^o$ out in in};
  \item one direction with no input arguments:
  \lstinline{add$^o$ out out out};
  \item one direction when all arguments are input:
  \lstinline{add$^o$ in in in};
\end{itemize}
When all arguments of a relation are input arguments, it works as a predicate, while passing no arguments corresponds to the generation of all valid values for all arguments of a relation.

In the rest of this section we describe a translation scheme which allows to implement principal directions of a relation as functions.
Each direction we consider illustrates some aspect of the translation.
Functional implementations of the principal directions of the \lstinline{add$^o$ x y z} relation which does not make into this section, may be found in Appendix.

\subsection{Basic Translation}

Consider \lstinline{add$^o$ in in out}.
This direction can be expressed as a function presented in Listing~\ref{add_x_y}.
The relation \lstinline{add$^o$ x y z} has two branches in a \conde: one unifies \x with \zero and the other --- with \lstinline{S x'}.
Since we know that \x is always ground in this direction, we can replace unifications with a pattern-matching.

When \x unifies with \zero, the rest of the \conde branch is the unification \lstinline{y === z}.
This unification means that the output value of the direction is equal to \y.
Thus we can just return \y as the result when \x is pattern-matched with \zero.

Now consider the \conde branch in which \x unifies with \lstinline{S x'} where \lstinline{x'} is a fresh variable.
The variable \x in this direction is always ground, thus \lstinline{x'} is also ground after unification.
This means, that the recursive call \lstinline{add$^o$ x' y z'} is done in the direction \lstinline{add$^o$ in in out} and can be translated into a recursive call to the function \lstinline{addXY}.
This recursive call computes the value of \lstinline{z'}, making it ground.
The only thing that is left is to apply the constructor \lstinline{S} to the result of the recursive call, since \lstinline{z === S z'}.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_x_y}, caption={Function for \lstinline{addo in in out} direction}, captionpos=b, frame=tb]
addXY :: Nat -> Nat -> Nat
addXY x y =
  case x of
    O -> y
    S x' -> S (addXY x' y)
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Nondeterministic Directions}

Running a relation in a given direction may succeed with one \emph{or more} possible answers or it may fail, i.e. it may run nondeterministically.
It is natural to implement nondeterminism by using Streams which are at the core of \mk.
One example in which there are multiple answers is \lstinline{add$^o$ out out in}.
This direction corresponds to finding all pairs of numbers which sum up to the given \z and can be implemented as shown in Listing~\ref{add_z}.

In this case, the input variable \z does not discriminate two branches of \conde.
Although the second branch of \conde unifies \z with a term \lstinline{S z'}, the first branch unifies \z with a free variable \y.
In this case we need to consider the two branches independently and then combine the results into a new stream.

The first \conde branch produces a single answer in which \x is \zero, and \y is equal to \z.
This single result is then wrapped into a singleton stream.

The second \conde branch succeeds only if \z is a successor of another value, thus when \z is a \zero we should fail.
We express this by pattern-matching on \z and returning an \lstinline{Empty} stream when \z is \zero.
Otherwise \z unifies with \lstinline{S z'}, which means that \lstinline{z'} is ground, and the recursive call to the relation is done in the direction \lstinline{add$^o$ out out in}.
This recursive call returns a stream of pairs \lstinline{(x', y)}, and by applying the constuctor \lstinline{S} to \lstinline{x'} we get the value of \x.

The two translated \conde branches are then combined by using \lstinline{`mplus`}: the same combinator which is used in \mk for disjunctions.
We use do-notation when translating the second branch of \conde which is just a syntactic sugar for the monadic bind operation \lstinline{>>=}.
Binds implement conjunctions in \mk and it is no surprise they fit well into the functional implementation.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_z}, caption={Function for \lstinline{addo out out in} direction}, captionpos=b, frame=tb]
addZ :: Nat -> Stream (Nat, Nat)
addZ z =
  return (O, z) `mplus`
  case z of
    O -> Empty
    S z' -> do
      (x', y) <- addZ z'
      return (S x', y)
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Free Variables in Answers}

In some directions, there are infinitely many answers, such as in \lstinline{add$^o$ in out out}.
When only the second argument is known, the answer is all pairs of numbers \lstinline{(y, z)} which satisfy \lstinline{x + y = z}.
In \mk, this is expressed with help of free variables.
Say \x is \lstinline{S O}, then the stream of answers is represented as \lstinline{(_.0, S _.0)}.
This means that whatever the value of \y is, \z is just its successor.
In our paper we only consider scenarios when the answers are ground, so we expect the stream of answers to be \lstinline{(O, S O), (S O, S (S O)), ...}.
To do it, we need to systematically generate a stream of ground values for \y and \z.
Currently, we leave the generation up to the user, but generators may be automatically created from their types.

Listing~\ref{add_x} shows the implementation of the direction \lstinline{add$^o$ in out out}.
This direction is very similar to the \lstinline{add$^o$ in in out}: we can pattern match on \x, call the same function recursively in the second \conde branch and construct the resulting value for \z by applying the constructor \lstinline{S}.
But in the case when \x is \zero, the only thing we know about the values of \y and \z is that they are equal.
In this case can generate a stream of all peano numbers for \z (or \y) and use them in the returned result.

The generation of all numbers is done as shown in Listing~\ref{add_x}, function \lstinline{genNat}.
The only thing one should be careful about, is to ensure lazy generation of the values, especially in case of an eager host language, such as \ocaml.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_x}, caption={Function for \lstinline{addo in out out} direction}, captionpos=b, frame=tb]
addX :: Nat -> Stream (Nat, Nat)
addX x =
  case x of
    O -> do
      z <- genNat
      return (z, z)
    S x' -> do
      (y, z') <- addX x'
      return (y, S z')

genNat :: Stream Nat
genNat = Mature O (S <$\dollar$> genNat)
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Predicates}

When all arguments of a relation are input, the direction serves as a predicate.
Consider \lstinline{add$^o$ in in in} and its functional implementation in Listing~\ref{add_x_y_z}.
In this case there is no actual answers we should return: the only thing that matters is whether the computation succeeded or failed.
Failure is expressed with an empty stream and success --- as a singleton stream with a unit value.

All arguments of the relation in this direction are ground.
This means, that all unification can be replaced with either pattern-matching or simple equality check.
When translating the first \conde branch we pattern match on \x, and then check if \y and \z are equal.
The second \conde branch introduces another pattern matching, this time on \z, which ensures that \z is not \zero.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_x_y_z}, caption={Function for \lstinline{addo in in in} direction}, captionpos=b, frame=tb]
addXYZ :: Nat -> Nat -> Nat -> Stream ()
addXYZ x y z =
  case x of
    O | y == z -> return ()
      | otherwise -> Empty
    S x' ->
      case z of
        O -> Empty
        S z' -> addXYZ x' y z'
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Order within Conjunctions}

Up until now we only seen examples with only one recursive call which is done to the same relation.
Many programs in \mk use several relations in the same bodies, see for example Listing~\ref{mult}.
The relation \lstinline{mult$^o$ x y z} relates variables such that \lstinline{x * y = z}.
The base cases in this relation are when \x or \y are \zero and \lstinline{S O}.
When \x unifies with a successor of another value, then we can use equalities \lstinline{(x' + 1) * y = x' * y + y}.
This is done by adding \y to the intermediate result of multiplying \lstinline{x'} by \y.

When translating it into a function for the given direction, we need to make sure to call functional counterparts of \lstinline{add$^o$} and \lstinline{mult$^o$} in the right order which depends on the direction.
Consider the direction \lstinline{mult$^o$ in in out}.
The translation of base cases is done with the same principals as the previous examples.
The last \conde branch contains two call to two different relations: \lstinline{add$^o$} and \lstinline{mult$^o$}.
Variables \lstinline{x'} and \y in this direction are ground, which impose possible directions on the relation calls.
There are two ways we can do these calls.

One of them is to first call \lstinline{add$^o$} in the direction \lstinline{add$^o$ in out out} since \y is ground, while \lstinline{r} and \lstinline{r'} are to be computed.
After this, all arguments in the call to \lstinline{mult$^o$} are known, and it can be used as a predicate \lstinline{mult$^o$ in in in}.
Finally, we return \lstinline{r} if the predicate succeeds: see Listing~\ref{mult_slow}.
Unfortunately, this order proves to bee too slow: it takes about half of a second to multiply 4 by 4, and more than 300 seconds to multiply 5 by 5.
This can be explained by the fact that \lstinline{add$^o$ in out out} generates an infinite streams of answers, only one which succeeds in multiplication, but considering them all even to find the first (and only) answer to \lstinline{multXY'} takes too much time.

Better and more efficient implementation of \lstinline{mult$^o$ in in out} is shown in Listing~\ref{mult_fast}.
Here, we first execute the recursive call of the direction \lstinline{mult$^o$ in in out}, and then use \lstinline{add$^o$ in in out} to compute the final result.
None of these relations produce an infinite stream, and the function runs in a fraction of a second.
You may note also that in this case there is no need to generate any additional functions for directions which are different from the one being translated.

In general, it is not clear how to choose the best order in which to translate calls within a conjunction.
One heuristic is to favor calls which do not produce infinite streams, namely do not use generators for free variables.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={mult}, caption={Multiplication relation}, captionpos=b, frame=tb]
let rec mult$^o$ x y z = conde [
  (x === O /\ z === O);
  (y === O /\ z === O);
  (x === S O /\ z === y);
  (y === S O /\ z === x);
  (fresh (x' r')
    (x === S x') /\
    (add y r' r) /\
    (mult x' y r')
   ) ]
    \end{lstlisting}
  \end{minipage}
\end{figure}

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={mult_slow}, caption={Inefficient implementation of \lstinline{multo in in out} direciton}, captionpos=b, frame=tb]
multXY' :: Nat -> Nat -> Stream Nat
multXY' O y = return O
multXY' x O = return O
multXY' (S O) y = return y
multXY' x (S O) = return x
multXY' (S x') y = do
  (r', r) <- addX y
  multXYZ x' y r'
  return r

multXYZ :: Nat -> Nat -> Nat -> Stream ()
multXYZ O y O = return ()
multXYZ x O O = return ()
multXYZ (S O) y z | y == z = return ()
multXYZ x (S O) z | x == z = return ()
multXYZ (S x') y z = do
  z' <- multXY' x' y
  addXYZ y z' z
multXYZ _ _ _ = Empty
    \end{lstlisting}
  \end{minipage}
\end{figure}

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={mult_fast}, caption={Efficient implementation of \lstinline{multo in in out} direciton}, captionpos=b, frame=tb]
multXY :: Nat -> Nat -> Stream Nat
multXY O y = return O
multXY x O = return O
multXY (S O) y = return y
multXY x (S O) = return x
multXY (S x') y = do
  r' <- multXY x' y
  addXY y r'
    \end{lstlisting}
  \end{minipage}
\end{figure}
