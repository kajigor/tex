\section{Examples of Translation}

A relation \lstinline{add$^o$ x y z} succeeds whenever \z is a sum of \x and \y.
An implementation of this relation which uses Peano numbers is shown in Listing~\ref{add}.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add}, caption={Addition relation}, captionpos=b, frame=tb]
let rec add$^o$ x y z = conde [
  (x === O /\ y === z);
  (fresh (x' z')
    (x === S x' /\
     z === S z' /\
     add$^o$ x' y z') ) ]
    \end{lstlisting}
  \end{minipage}
\end{figure}

One can run a relation in some \emph{direction} by passing it \emph{input} arguments.
For example, executing \lstinline{add$^o$ (S O) O z} finds the sum of the first two arguments and maps \lstinline{z} to the sum \lstinline{S O}.
We can also provide only the last argument: \lstinline{add$^o$ x y (S O)}.
This computes all pairs of Peano numbers \lstinline{(x, y)} which sum up to the given value \lstinline{z = S O} which are \lstinline{(O, S O)} and \lstinline{(S O, O)}.
Moreover, we can pass as input arguments not only \emph{ground terms} but terms which contain fresh variables, such as \lstinline{add$^o$ x (S y) z}.
Executing this relation finds all triples \lstinline{(x, y, z)} such that \lstinline{x + (y + 1) = z}.
Running in some directions can fail.
For example \lstinline{add$^o$ (S x) y O} may never succeed, since \lstinline{(1 + x) + y} can never be equal to \zero.

There exists a multitude of different directions for each relation.
In this paper we only consider directions in which input arguments are ground, i.e. do not contain any fresh variables, we will call them \emph{principal directions}.
We denote a principal direction by the name of a relation followed by specification of its arguments: in place of each argument we write either \lstinline{in} when the argument is input or \lstinline{out} if it is output.
There are $8$ principal directions for \lstinline{add$^o$ x y z}:
\begin{itemize}
  \item three directions with one input: \lstinline{add$^o$ in out out},

  \lstinline{add$^o$ out in out}, and \lstinline{add$^o$ out out in};
  \item three directions with two inputs: \lstinline{add$^o$ in in out},

  \lstinline{add$^o$ in out in}, \lstinline{add$^o$ out in in};
  \item one direction with no input arguments:
  \lstinline{add$^o$ out out out};
  \item one direction when all arguments are input:
  \lstinline{add$^o$ in in in};
\end{itemize}
When all arguments of a relation are input arguments, it works as a predicate, while passing no arguments corresponds to the generation of all valid values for all arguments of a relation.

In the rest of this section we describe a translation scheme which allows to implement principal directions of a relation as functions.
Each direction we consider illustrates some aspect of the translation.
Functional implementations of the principal directions of the \lstinline{add$^o$ x y z} relation which does not make into this section, may be found in Appendix.

\subsection{Basic Translation}

Consider \lstinline{add$^o$ in in out}.
This direction can be expressed as a function presented in Listing~\ref{add_x_y}.
The relation \lstinline{add$^o$ x y z} has two branches in a \conde: one unifies \x with \zero and the other --- with \lstinline{S x'}.
Since we know that \x is always ground in this direction, we can replace unifications with a pattern-matching.

When \x unifies with \zero, the rest of the \conde branch is the unification \lstinline{y === z}.
This unification means that the output value of the direction is equal to \y.
Thus we can just return \y as the result when \x is pattern-matched with \zero.

Now consider the \conde branch in which \x unifies with \lstinline{S x'} where \lstinline{x'} is a fresh variable.
The variable \x in this direction is always ground, thus \lstinline{x'} is also ground after unification.
This means, that the recursive call \lstinline{add$^o$ x' y z'} is done in the direction \lstinline{add$^o$ in in out} and can be translated into a recursive call to the function \lstinline{addXY}.
This recursive call computes the value of \lstinline{z'}, making it ground.
The only thing that is left is to apply the constructor \lstinline{S} to the result of the recursive call, since \lstinline{z === S z'}.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_x_y}, caption={Function for \lstinline{addo in in out} direction}, captionpos=b, frame=tb]
addXY :: Nat -> Nat -> Nat
addXY x y =
  case x of
    O -> y
    S x' -> S (addXY x' y)
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Nondeterministic Directions}

Running a relation in a given direction may succeed with one \emph{or more} possible answers or it may fail, i.e. it may run nondeterministically.
It is natural to implement nondeterminism by using Streams which are at the core of \mk.
One example in which there are multiple answers is \lstinline{add$^o$ out out in}.
This direction corresponds to finding all pairs of numbers which sum up to the given \z and can be implemented as shown in Listing~\ref{add_z}.

In this case, the input variable \z does not discriminate two branches of \conde.
Although the second branch of \conde unifies \z with a term \lstinline{S z'}, the first branch unifies \z with a free variable \y.
In this case we need to consider the two branches independently and then combine the results into a new stream.

The first \conde branch produces a single answer in which \x is \zero, and \y is equal to \z.
This single result is then wrapped into a singleton stream.

The second \conde branch succeeds only if \z is a successor of another value, thus when \z is a \zero we should fail.
We express this by pattern-matching on \z and returning an \lstinline{Empty} stream when \z is \zero.
Otherwise \z unifies with \lstinline{S z'}, which means that \lstinline{z'} is ground, and the recursive call to the relation is done in the direction \lstinline{add$^o$ out out in}.
This recursive call returns a stream of pairs \lstinline{(x', y)}, and by applying the constuctor \lstinline{S} to \lstinline{x'} we get the value of \x.

The two translated \conde branches are then combined by using \lstinline{`mplus`}: the same combinator which is used in \mk for disjunctions.
We use do-notation when translating the second branch of \conde which is just a syntactic sugar for the monadic bind operation \lstinline{>>=}.
Binds implement conjunctions in \mk and it is no surprise they fit well into the functional implementation.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_z}, caption={Function for \lstinline{addo out out in} direction}, captionpos=b, frame=tb]
addZ :: Nat -> Stream (Nat, Nat)
addZ z =
  return (O, z) `mplus`
  case z of
    O -> Empty
    S z' -> do
      (x', y) <- addZ z'
      return (S x', y)
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Free Variables in Answers}

In some directions, there are infinitely many answers, such as in \lstinline{add$^o$ in out out}.
When only the second argument is known, the answer is all pairs of numbers \lstinline{(y, z)} which satisfy \lstinline{x + y = z}.
In \mk, this is expressed with help of free variables.
Say \x is \lstinline{S O}, then the stream of answers is represented as \lstinline{(_.0, S _.0)}.
This means that whatever the value of \y is, \z is just its successor.
In our paper we only consider scenarios when the answers are ground, so we expect the stream of answers to be \lstinline{(O, S O), (S O, S (S O)), ...}.
To do it, we need to systematically generate a stream of ground values for \y and \z.
Currently, we leave the generation up to the user, but generators may be automatically created from their types.

Listing~\ref{add_x} shows the implementation of the direction \lstinline{add$^o$ in out out}.
This direction is very similar to the \lstinline{add$^o$ in in out}: we can pattern match on \x, call the same function recursively in the second \conde branch and construct the resulting value for \z by applying the constructor \lstinline{S}.
But in the case when \x is \zero, the only thing we know about the values of \y and \z is that they are equal.
In this case can generate a stream of all peano numbers for \z (or \y) and use them in the returned result.

The generation of all numbers is done as shown in Listing~\ref{add_x}, function \lstinline{genNat}.
The only thing one should be careful about, is to ensure lazy generation of the values, especially in case of an eager host language, such as \ocaml.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_x}, caption={Function for \lstinline{addo in out out} direction}, captionpos=b, frame=tb]
addX :: Nat -> Stream (Nat, Nat)
addX x =
  case x of
    O -> do
      z <- genNat
      return (z, z)
    S x' -> do
      (y, z') <- addX x'
      return (y, S z')

genNat :: Stream Nat
genNat = Mature O (S <$\dollar$> genNat)
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Predicates}

When all arguments of a relation are input, the direction serves as a predicate.
Consider \lstinline{add$^o$ in in in} and its functional implementation in Listing~\ref{add_x_y_z}.
In this case there is no actual answers we should return: the only thing that matters is whether the computation succeeded or failed.
Failure is expressed with an empty stream and success --- as a singleton stream with a unit value.

All arguments of the relation in this direction are ground.
This means, that all unification can be replaced with either pattern-matching or simple equality check.
When translating the first \conde branch we pattern match on \x, and then check if \y and \z are equal.
The second \conde branch introduces another pattern matching, this time on \z, which ensures that \z is not \zero.

\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={add_x_y_z}, caption={Function for \lstinline{addo in in in} direction}, captionpos=b, frame=tb]
addXYZ :: Nat -> Nat -> Nat -> Stream ()
addXYZ x y z =
  case x of
    O | y == z -> return ()
      | otherwise -> Empty
    S x' ->
      case z of
        O -> Empty
        S z' -> addXYZ x' y z'
    \end{lstlisting}
  \end{minipage}
\end{figure}

\subsection{Different Directions within One Function}

\todo{Mult example}

\subsection{Order within Conjunctions}

\todo{Example where order matters }