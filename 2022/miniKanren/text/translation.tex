\section{Translation by Examples}

In this section we present a scheme for translation of a \mk relation with a given mode into pure functions.
We start by exploring examples which are translated straightforwardly, and then consider aspects of relational programming which complicate translation considerably.
We will then describe how translation scheme must be adjusted to incorporate these complicated features.

\subsection{The Simplest Case}

For a relation \lstinline{add$^o$ x y z} with the mode \lstinline{(in, in, out) is det} we can easily construct a pure function which has the same semantics: see Listing~\ref{addXY}.
We construct this function using the following thinking.
The relation \lstinline{add$^o$} is comprised of a single disjunction (\conde).
Each disjunct involves a unification of a known (\lstinline{in}) variable \x.
These unifications of \x are disjunct: there may only be one succeeding disjunct in the \conde when computed with a particular ground value of \x.
This naturally translates into a pattern matching on \x with two possible branches: either \x is \lstinline{zero} or a \lstinline{succ} of some other value.
The bodies of both branches are then generated using the remaining conjuncts in the conde branches.
The unifications of \z rule how the result can be constructed when other variables are known.
The body of the first branch of the pattern match is thus just \y.
The second branch of the disjunction involves a recursive call to the \lstinline{add$^o$} relation and a unification of \z.
A recursive call to \lstinline{add$^o$} relation is done in the mode \lstinline{(in, in, out)} since \y is known and \lstinline{x'} is a unification with a known variable.
This means that here we can do a recursive call to the function \lstinline{add_x_y}.
The only thing left is constructing a resulting value which corresponds to \z by applying \lstinline{succ} to the result of the recursive call.

\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.68\textwidth}
    \begin{lstlisting}[label={addXY}, caption={Functional representation of \lstinline{addo x y z} with the mode \lstinline{(in, in, out) is det}}, captionpos=b, frame=tb]
let rec add_x_y x y =
  match x with
  | zero -> y
  | succ x' -> succ (add_x_y x' y)
    \end{lstlisting}
  \end{minipage}
\end{figure*}

\subsection{Nondeterminism}

The simplest translation scheme works, but in a very small number of potential modes.
First of all, the mode must be deterministic for that translation scheme to work.
If there are multiple answers, then we have to express nondeterminism somehow.
One natural way is to use the simplest nondeterminism monad: a list, to represent the resulting value.

Consider the same relation \lstinline{add$^o$ x y z}, but with the mode \lstinline{(out, out, in) is nondet}.
This case is about finding all pairs of values which sum up to the given \z.
Querying this relation with the value of \lstinline{z = succ zero} must compute two answers for \x and \y: \lstinline{(zero, succ zero)} and \lstinline{(succ zero, zero)}.
The first answer comes from the first branch of the \conde, when \z is unified with \y, and \x is zero.
The second answer is computed in the second branch of \conde, after a recursive call to \lstinline{add$^o$} is done with the argument equal to \lstinline{zero}.

Notice that the value of \z do not discriminate the two branches of \conde.
We know that \z cannot be \lstinline{zero} in the second branch, but the first branch do not restrict the value of \z at all.
This means that when \z is zero, answers should be generated from both branches of \conde.
One way of implementing this is shown in Listing~\ref{addZ}.
Here we concatenate the results which are generated by the first and the second branches of \conde via a list concatenation operator \lstinline{@}.
The first branch universally provides a single answer \lstinline{(0, z)}, while the other branch does a recursive call to the \lstinline{add_z} function and then applies \lstinline{succ} constructor to \x.

\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.68\textwidth}
    \begin{lstlisting}[label={addZ}, caption={Functional representation of \lstinline{addo x y z} with the mode \lstinline{(out, out, in) is nondet}}, captionpos=b, frame=tb]
let rec add_z z =
  [(0, z)] @
  match z with
  | succ z' -> List.map (fun x y -> (succ x, y)) (add_z (z - 1))
  | _ -> []
    \end{lstlisting}
  \end{minipage}
\end{figure*}

\subsection{Infinitely Many Answers}

Lists serves well as an abstraction to capture nondeterminism.
However, there are infinitely many answers sometimes which may pose a problem in case of eager host languages such as \ocaml.
Consider \lstinline{add$^o$ x y z} with the mode \lstinline{(out, in, out) is nondet}.
Here we compute all values \x and \z that \lstinline{x + y = z} when \y is given.
Although the implementation of this function is straightforward (see Listing~\ref{addY}), it contains infinite recursion which generates infinite number of answers.
When the host language is lazy, one can force only the first $n$ answers, while in an eager host language additional care must be taken.

\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.68\textwidth}
    \begin{lstlisting}[label={addY}, caption={Functional representation of \lstinline{addo x y z} with the mode \lstinline{(out, in, out) is nondet}}, captionpos=b, frame=tb]
let rec add_y y =
  [(0, y)] @  List.map (fun x z -> (succ x, succ z)) (add_y y)
    \end{lstlisting}
  \end{minipage}
\end{figure*}

\todo{Move to a subsection about miniKanren streams.}
The problem of the infinite number of answers gets more complicated when the user expects only a single answer, but computing it involves intermediate infinite list.
In this case there is no way to just force only the first answers, they all have to be considered. \todo{Example}.

\subsection{Generators}

Some relations in some modes do not restrict certain variables at all.
Consider the relation \lstinline{lookup$^o$ xs i v} in which the \lstinline{i}-th element of the list \lstinline{xs} is \lstinline{v} (see Listing~\ref{lookup}).
When run with the mode \lstinline{(out, out, in) is nondet} this relation computes all list-index pairs, such that one element of the list is fixed and given.
No restrictions exist for any other elements of the list, neither the length of the list is known.
In \mk this can be expressed as a reified value \lstinline{(i, _.0 :: ... :: _.(i - 1) :: v :: _.i)}, where \lstinline{v} is the input ground value.
This is not a ground term, and to provide a set of answers for the end user we need a way to generate the fresh elements of the list which come before the given value, as well as the tail of the list which comes after it.

One extra caveat is that we need to take care of what values we generate.
In this example, the index must be a number, while the elements of the list have the same type as the given value \lstinline{v}, assuming the host language is strictly typed such as \haskell or \ocaml.
Once we determined the types of the values to be generated, then we may use some automatic system for generating values by types, \todo{such as used in property based testing, for example}.
However, if there is no type restriction on a fresh value, or the host languages \todo{is not typed, such as Scheme}, the only way to choose a proper generator is to as the user to provide it.
For now, we decided to use user-provided generators always, but we will try to lift this restriction whenever possible in future work.

\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.28\textwidth}
    \begin{lstlisting}[label={lookup}, caption={Lookup relation}, captionpos=b, frame=tb]
let rec lookup xs i v =
  fresh (h tl) (xs === h :: tl) /\ conde [
    (i === zero /\ h === v) ;
    (fresh (k) (i === succ k /\ lookup tl k v))
  ]
    \end{lstlisting}
  \end{minipage}
\end{figure*}

\subsection{Interleaving Answers}

It is easy to deal with an infinite number of answers of a top-level relation: laziness and forcing only a finite number of answers does the trick.
If some intermediate computation constructs an infinite number of answers, then matters become more complicated.
Consider the \lstinline{eval$^o$ fm st result} relation on Listing~\ref{eval}.
It evaluates a propositional formula \lstinline{fm} with a variable mapping \lstinline{st} to get the \lstinline{result}.
Formula may be either a boolean literal \lstinline{lit b}, a variable \lstinline{var i}, indexed by a number, a negation of another formula \lstinline{neg n}, a conjunction or disjunction of two formulas: \lstinline{conj x y} and \lstinline{disj x y} correspondingly.
A variable mapping \lstinline{st} is just a list, \lstinline{i}-th element of which is a boolean number assigned to a formula \lstinline{var i}.
The mode \lstinline{(out, in, in) is nondet} corresponds to generation of formulas which evaluate to the given \lstinline{result} with the given variable mapping \lstinline{st}.
In case of conjunctions and disjunctions, we first need to generate its two subformulas and then apply the corresponding constructor.
There are infinitely many formulas which evaluate to the given result which entails infinite number of subformulas.
In order to start generating the second subconjunction, one needs to finish generating all possible first subconjunctions which is impossible when using lists as an abstraction for several answers.

An answer to this conundrum already exists in \mk.
The answers computed by different intermediate computations can be organized as Streams and then interleaved, so that new answers could be constructed.
This change does not really change anything major in the implementation, but allows for better dealing with infinite streams of answers

\begin{figure*}[!t]
  \centering
  \begin{minipage}{\textwidth}
    \begin{lstlisting}[label={eval}, caption={A simple evaluator relation}, captionpos=b, frame=tb]
let rec eval$^o$ fm st result = conde [
  (fm === lit b /\ result === b);
  (fm === var i /\ lookup$^o$ st i result);
  (fm === neg x /\ not$^o$ v result /\ eval$^o$ x st v);
  (fm === conj x y /\ and$^o$ v w result /\ eval$^o$ x st v /\ eval$^o$ y xs w);
  (fm === disj x y /\ or$^o$ v w result /\ eval$^o$ x st v /\ eval$^o$ y xs w)
  ]
    \end{lstlisting}
  \end{minipage}
\end{figure*}








\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.38\textwidth}
    \begin{lstlisting}[label={append}, caption={List concatenation relation}, captionpos=b, frame=tb]
let rec append$^o$ xs ys zs = conde [
  (x === [] /\ y === z);
  (fresh (h t z')
    (x === h :: t /\
     z === h :: z' /\
     append$^o$ t y z') ) ]
    \end{lstlisting}
  \end{minipage}
\end{figure*}







