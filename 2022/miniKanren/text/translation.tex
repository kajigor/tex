\section{Translation by Examples}

In this section we present a scheme for translation of a \mk relation with a given mode into pure functions.
We start by exploring examples which are translated straightforwardly, and then consider aspects of relational programming which complicate translation considerably.
We will then describe how translation scheme must be adjusted to incorporate these complicated features.

\subsection{The Simplest Case}

For a relation \lstinline{add$^o$ x y z} with the mode \lstinline{(in, in, out) is det} we can easily construct a pure function which has the same semantics: see Listing~\ref{addXY}.
We construct this function using the following thinking.
The relation \lstinline{add$^o$} is comprised of a single disjunction (\conde).
Each disjunct involves a unification of a known (\lstinline{in}) variable \x.
These unifications of \x are disjunct: there may only be one succeeding disjunct in the \conde when computed with a particular ground value of \x.
This naturally translates into a pattern matching on \x with two possible branches: either \x is \lstinline{zero} or a \lstinline{succ} of some other value.
The bodies of both branches are then generated using the remaining conjuncts in the conde branches.
The unifications of \z rule how the result can be constructed when other variables are known.
The body of the first branch of the pattern match is thus just \y.
The second branch of the disjunction involves a recursive call to the \lstinline{add$^o$} relation and a unification of \z.
A recursive call to \lstinline{add$^o$} relation is done in the mode \lstinline{(in, in, out)} since \y is known and \lstinline{x'} is a unification with a known variable.
This means that here we can do a recursive call to the function \lstinline{add_x_y}.
The only thing left is constructing a resulting value which corresponds to \z by applying \lstinline{succ} to the result of the recursive call.

\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.68\textwidth}
    \begin{lstlisting}[label={addXY}, caption={Functional representation of \lstinline{addo x y z} with the mode \lstinline{(in, in, out) is det}}, captionpos=b, frame=tb]
let rec add_x_y x y =
  match x with
  | zero -> y
  | succ x' -> succ (add_x_y x' y)
    \end{lstlisting}
  \end{minipage}
\end{figure*}

\subsection{Nondeterminism}

The simplest translation scheme works, but in a very small number of potential modes.
First of all, the mode must be deterministic for that translation scheme to work.
If there are multiple answers, then we have to express nondeterminism somehow.
One natural way is to use the simplest nondeterminism monad: a list, to represent the resulting value.

Consider the same relation \lstinline{add$^o$ x y z}, but with the mode \lstinline{(out, out, in) is nondet}.
This case is about finding all pairs of values which sum up to the given \z.
Querying this relation with the value of \lstinline{z = succ zero} must compute two answers for \x and \y: \lstinline{(zero, succ zero)} and \lstinline{(succ zero, zero)}.
The first answer comes from the first branch of the \conde, when \z is unified with \y, and \x is zero.
The second answer is computed in the second branch of \conde, after a recursive call to \lstinline{add$^o$} is done with the argument equal to \lstinline{zero}.

Notice that the value of \z do not discriminate the two branches of \conde.
We know that \z cannot be \lstinline{zero} in the second branch, but the first branch do not restrict the value of \z at all.
This means that when \z is zero, answers should be generated from both branches of \conde.
One way of implementing this is shown in Listing~\ref{addZ}.
Here we concatenate the results which are generated by the first and the second branches of \conde via a list concatenation operator \lstinline{@}.
The first branch universally provides a single answer \lstinline{(0, z)}, while the other branch does a recursive call to the \lstinline{add_z} function and then applies \lstinline{succ} constructor to \x.

\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.68\textwidth}
    \begin{lstlisting}[label={addZ}, caption={Functional representation of \lstinline{addo x y z} with the mode \lstinline{(out, out, in) is nondet}}, captionpos=b, frame=tb]
let rec add_z z =
  [(0, z)] @
  match z with
  | succ z' -> List.map (fun x y -> (succ x, y)) (add_z (z - 1))
  | _ -> []
    \end{lstlisting}
  \end{minipage}
\end{figure*}

\subsection{Infinitely Many Answers}

Lists serves well as an abstraction to capture nondeterminism.
However, there are infinitely many answers sometimes which may pose a problem in case of eager host languages such as \ocaml.
Consider \lstinline{add$^o$ x y z} with the mode \lstinline{(out, in, out) is nondet}.
Here we compute all values \x and \z that \lstinline{x + y = z} when \y is given.
Although the implementation of this function is straightforward (see Listing~\ref{addY}), it contains infinite recursion which generates infinite number of answers.
When the host language is lazy, one can force only the first $n$ answers, while in an eager host language additional care must be taken.

\begin{figure*}[!t]
  \centering
  \begin{minipage}{0.68\textwidth}
    \begin{lstlisting}[label={addY}, caption={Functional representation of \lstinline{addo x y z} with the mode \lstinline{(out, in, out) is nondet}}, captionpos=b, frame=tb]
let rec add_y y =
  [(0, y)] @  List.map (fun x z -> (succ x, succ z)) (add_y y)
    \end{lstlisting}
  \end{minipage}
\end{figure*}

\todo{Move to a subsection about miniKanren streams.}
The problem of the infinite number of answers gets more complicated when the user expects only a single answer, but computing it involves intermediate infinite list.
In this case there is no way to just force only the first answers, they all have to be considered. \todo{Example}.

\subsection{Generators}

\todo{This all is wrong, should be rewritten with a more suitable example which really involves a generator}
Some relations do not restrict some of the variables at all.
Consider the relation \lstinline{append$^o$ xs ys zs} which concatenates the lists \lstinline{xs} and \lstinline{ys} to get the result \lstinline{zs} (Listing~\ref{append}).
Whatever the mode of this relation is, it never restricts the value of the fresh variable \lstinline{h}.
Our objective is to implement a function which computes \emph{ground} answers, but since \lstinline{h} is never restricted in any way, there is no way to provide ground elements of lists.
One to solve this problem is by asking the end user to provide a generator of the values which can be used as elements of the list.
Sometimes, this information can be derived from the task or from the type annotations, if the host language is typed.

\begin{figure}[!t]
  \centering
  \begin{minipage}{0.28\textwidth}
    \begin{lstlisting}[label={append}, caption={List concatenation relation}, captionpos=b, frame=tb]
let rec append$^o$ xs ys zs = conde [
  (x === [] /\ y === z);
  (fresh (h t z')
    (x === h :: t /\
     z === h :: z' /\
     append$^o$ t y z') ) ]
    \end{lstlisting}
  \end{minipage}
\end{figure}







