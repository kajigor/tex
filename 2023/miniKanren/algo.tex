\section{Algorithm for Functional Conversion}

\begin{enumerate}
    \item Describe the algorithm in detail, step by step.
    \item Discuss the key techniques and transformations involved in functional conversion.
    \item Provide pseudocode or code snippets to illustrate the algorithm.
\end{enumerate}

\subsection{Mode Analysis}

We only consider two possible modes for variables: \emph{in} and \emph{out}. 
The first mode is a shorthand for a mapping $ground \rightarrow ground$ and correspond to the input variables. 
The second mode is a shorthand for $free \rightarrow ground$ corresponding to the output variables. 

The mode inference is run on relation with a fixed direction, whose body has been normalized. 
First, we initialize all encounters of variables which come from arguments of the relation. 
For each of these variables, we know that they are either \emph{ground} or \emph{free}, and can propagate this information to the body of the relation. 

Then we start inference for goal in the body of the relation. 
This goal is always a disjunction, and each disjunction can be analyzed independently. 

To analyze a unification, both sides of it are examined and the information about groundness is propagated. 

Once a variable become ground, it stays ground in the subsequent conjuncts. 

The order of conjuncts influences the performance of a relation. 
Some conjuncts, such as guards \todo{(introduce the 4 types of unifications sooner)}, are better to be run as soon as possible: they can either fail or succeed without producing multiple results. 
Running them sooner can only make the search space smaller. 
Another example is assignments and matches, which can produce one result in the worst case. 
Generators, on the other hand, should be delayed as much as possible, since they generally produce infinitely many results. 

In light of these considerations, we make a priority list of different conjuncts and pick conjuncts in the order of that priority. 

The pseudocode for the mode inference can be found in figure \todo(reference the figure). 


\begin{figure}[!t]
  \centering
  \begin{minipage}{\columnwidth}
    \begin{lstlisting}[label={modeInference},
                       caption={Mode inference pseudocode},
                       captionpos=b,
                       frame=tb]
-- Augments variables with the initial mode information: 
-- * input variables have initial instantiation g 
-- * all other variables have initial instantiation f 
initModes :: $\Def_{V}^N$ -> $\Def_{(V, M)}^N$

modeInfer ($R_{i}\left( x_1, \ldots, x_{k_{i}} \right) \equiv body$) = 
  ($R_{i}\left( x_1, \ldots, x_{k_{i}} \right) \equiv$ (modeInferDisj body)

modeInferDisj ($\bigvee\left( c_1, \ldots, c_{n} \right)$) =
  $\bigvee( $modeInferConj $ c_1, \ldots, $ modeInferConj $ c_{n})$  

modeInferConj ($\bigwedge\left( g_1, \ldots, g_n \right)$) = 
  let (picked, theRest) = pickConjunction($\left[ g_1, \ldots, g_n \right]$) in 
  let moddedPicked = modeInferBase picked in 
  let moddedConjs = modeInferConj ($\bigwedge$ theRest) in 
  $\bigwedge($moddedPicked : moddedConjs)

modeInferBase 

    \end{lstlisting}
  \end{minipage}
\end{figure}