% EPTCS Style distribution v1.7.0 released May 23, 2022.
% https://github.com/EPTCS/style
\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{HCVS 2024} % Name of the event you are submitting to
\bibliographystyle{eptcs}

\input{packages}
\input{defs}

\ifpdf
  \usepackage{underscore}         % Only needed if you use pdflatex.
  \usepackage[T1]{fontenc}        % Recommended with pdflatex
\else
  \usepackage{breakurl}           % Not needed if you use pdflatex only.
\fi


\usepackage{pdfpages}

\title{Integration of Offline Partial Deduction and\\ Functional Conversion for miniKanren}
\author{Aleksandr Shefer
\institute{Constructor University \\ Bremen, Germany}
\institute{JetBrains Research \\
Germany}
\email{alex.shefer.31@gmail.com}
\and
Ekaterina Verbitskaia
\institute{Constructor University \\ Bremen, Germany}
\institute{JetBrains Research \\ Amsterdam, Netherlands}
\email{kajigor@gmail.com}
}
\def\titlerunning{Integration of Offline Partial Deduction and Functional Conversion for miniKanren}
\def\authorrunning{A. Shefer, E. Verbitskaia}
\begin{document}


\maketitle

\begin{abstract}

In pure logic programming, a program is viewed as a relation that can be queried in different directions to find solutions for multiple problems. 
For example, an interpreter can both evaluate and synthesize programs. 
Unfortunately, the performance of the queries is a great concern, and sometimes it is impossible to create a relation that executes in all directions in a reasonable time. 
Program transformation techniques such as partial deduction and functional conversion have previously shown their potential when the execution direction of a relation is known. 
In this extended abstract, we present the integration of offline partial deduction with functional conversion, capable of greater performance improvement compared to the transformations run individually. 

\end{abstract}

\section{Introduction}

Logic programming facilitates a relational style in which programs do not distinguish between input and output arguments~\cite{TheReasonedSchemer}. 
Any program can solve many problems by being evaluated in different directions, notably forward and backward. 
Employing a complete search strategy, such as the interleaving search of \kanren \footnote{Kanren is a family of pure relational programming languages, website: \url{http://minikanren.org}}, and abstaining from using extra-logical constructs such as cuts allows producing every solution to a query in any direction~\cite{kiselyov2005backtracking}. 
This approach, called relational programming, is capable of producing solvers by running a relational interpreter backwards~\cite{lozov2019relational}.
For instance, a relational sorting algorithm can generate permutations while a program interpreter can be inverted to become a synthesizer. 

The main issue with the approach is its inefficiency.
Relational interpreters are either generated by relational conversion from a function or crafted by a person who has a specific, usually forward, direction in mind. 
In both cases, the interpreter often shows reasonable performance in the forward direction, but not necessarily when executed in any other direction. 
Besides, logic languages come with additional overhead, such as expensive unification with occurs-check. 
Finally, being an embedded domain-specific language, \kanren comes with an interpretation overhead which also affects performance. 

In has been shown that partial deduction can alleviate some of the interpretation overhead~\cite{de1999conjunctive, EPTCS341.5}.
Additionally, functional conversion is capable of improving the execution time of a program by translating it into a functional language in the context of a given direction~\cite{verbitskaia2024conversion}. 
While doing so, costly logical operations are replaced with much cheaper functional counterparts. 
We believe that combining the two approaches together can lead to even bigger speed-ups. 

This extended abstract focuses on integrating an offline partial deduction algorithm with a functional conversion for a \mk\footnote{\mk is a minimal language in the \kanren family} programming language. 
We illustrate the approach with an example and provide the preliminary evaluation that demonstrates noticeable execution time improvement.

\section{Combining Specialization Methods for Relational Programming}

Knowing values of some arguments of a relation or its direction enables specialization---an automatic program transformation aimed at improving the program's execution time~\cite{gallagher1993tutorial}. 
Previously, two approaches were explored in the context of \mk: online partial deduction~\cite{EPTCS341.5} and functional conversion~\cite{verbitskaia2024conversion}. 
The former symbolically executes a relation when the values or shape of some of its arguments are known at specialization-time. 
The latter converts a relational program into a function which produces the same results, but is devoid of costly operations inherent to a relational language, such as unification. 

Consider the relation \lstinline{sort$^o$} which relates the list \lstinline{x} with its sorted counterpart \lstinline{y}. 
The implementation follows directly from the definition of a sorted list: it is either empty or its head is the smallest element of the list, and its tail is sorted. 
This is encoded as the disjunction (\lstinline{\/}) of two conjunctions (\lstinline{/\}) which unify (\lstinline{===}) the sorted list with the empty and non-empty list constructors correspondingly. 
The relation \lstinline{smallest$^o$ x s xs} relates the list \lstinline{x}, its smallest element \lstinline{s} and the list of remaining elements \lstinline{xs}. 

\input{fig/relSortSimplified}

If it is known that the relation \lstinline{sort$^o$} is always going to be executed on lists of a certain length, say 10, \lstinline{sort$^o$} will only be called a finite number of times (11, to be exact).
Moreover, only one of the two disjuncts will succeed on every call. 
A partial deduction algorithm will unfold a body of the relation the appropriate number of times and partially evaluate it, thereby removing some of the unnecessary computations. 
More sophisticated techniques, such as Conjunctive Partial Deduction~\cite{de1999conjunctive}, include the information about variable sharing or run additional analyses and use it in the transformations. 

Functional conversion translates the relation into a function in the context of a specific direction. 
While doing so, it replaces expensive unifications with much cheaper equality checks, variable bindings or term construction operations---based on which role the unification serves in the given direction. 
For example, if we know that \lstinline{sort$^o$} is run with the second argument known, then unifications of \lstinline{y} may be replaced with a pattern match. 
One peculiar thing about \lstinline{sort$^o$} is that it is impossible to write a single program which behaves well in both directions. 
Depending on the order of calls to \lstinline{smallest$^o$} and \lstinline{sort$^o$} it will quickly time out when sorting or when generating permutations. 
Using mode analysis, functional conversion puts the calls in the order best suited for the particular direction.  

Both transformations are capable of achieving significant results; combining them together is the next logical step. 
But we first had to address a couple of shortcomings of the previous works. 
Online partial deduction tends to produce extremely large programs due to making all the decisions at specialization-time without running any analysis beforehand. 
Apart from that, partial deduction will benefit from knowing the order of calls, which can be done by employing mode analysis implemented as a part of functional conversion. 
As a result, we decided to switch to offline partial deduction that runs static analyses such as binding time analysis, termination check and mode inference before partial evaluation. 

The resulting specialization algorithm is done in five steps. First, the user annotates the relation with its intended direction, namely which arguments are input and which are output. Then the relation is mode analysed, which reorders the conjuncts for the direction and annotates the other calls in the program. After that, a simple binding time analysis propagates the information about input arguments. It employs termination check to annotate which of the relation calls need to be unfolded at specialization-time. Next, partial deduction uses the results of the binding time analysis and mode analysis to partially evaluate the program. Finally, the resulting program in \mk is converted into a function in \haskell. 

We provide the result of the partial deduction of \lstinline{sort$^o$ x (0 :: 1 :: 2 :: [])} in Figure~\ref{fig:sortDeduced}. 
Our approach successfully unfolds the program completely, resulting in the enumeration of all possible answers to the query. 
Note that, depending on the relation, direction and the known values of the arguments, it is not always possible. 


\section{Evaluation}

At this point, we have only done a limited evaluation of our approach. 
Here we present the comparison of the described transformation with functional conversion and the online partial deduction algorithm. 
For that, we run the corresponding methods on two examples and compared the execution time. 

The first benchmark is \lstinline{sort$^o$} specialized for the backwards direction in which it generates all permutations of a given list. 
In this case, our approach results in a program which enumerates all possible answers, while both online partial deduction and functional conversion fail to achieve this degree of specialization.
The number of permutations grows rapidly as the list's length increases, so we only run the function on the list of length up to five. 
Querying it for the first five answers demonstrates the performance increase of 3 orders of magnitude compared with functional conversion and up to 5 orders of magnitude compared with online partial deduction: see first two rows in Table~\ref{tbl:times}. 

\input{fig/times}    

The second benchmark is the classic Tower of Hanoi puzzle. 
It is a representative program for verifier-to-solver approach. 
The program is given a sequence of disks' moves and checks if the finish state can be achieved from the start state by it. 
Initially, the program was written in a functional language and translated into \mk, then it was specialized in the direction which generates the sequence of steps, solving the puzzle. 
The result of querying for 5 possible answers is at least 5 orders of magnitude faster than both functional conversion and online partial deduction: see the last two rows in Table~\ref{tbl:times}. 

% \input{fig/hanoiTime}

\section{Conclusion and Future work}

In this abstract, we described the integration of offline partial deduction with functional conversion for \mk. 
Our preliminary evaluation showed solid performance improvement. 
We believe that it is a promising direction which is worth further investigation. 

 


% \section{Improvement of Functional Conversion with Offline Partial Deduction}

% In this section, we describe the algorithm of functional conversion (in our case, from \mk to \haskell). 

% Functional conversion with Offline Partial Deduction is done for relation with known input arguments (other arguments are output arguments). The goal is to create a function that will produce same results as initial relation. The algorithm of conversion looks like this: 
% \begin{enumerate}
%   \item Mode Inference is applied to the initial program with the indication of the target relation and input arguments. It obtains the mode for each variable and rearranges clauses in relations. 
%   \item Binding Time Analysis (\bta) is done: using the information of ground variables from previous step and termination checker, annotate the relation calls. These annotations will force \cpd to expand calls that the \bta deems safe.
%   \item Conjunctive Partial Deduction (\cpd) produces residual program taking annotations into account. 
%   \item Then Conversion produces function in Haskell language.
% \end{enumerate}

% Mode inference and Functional Conversion have been already discussed in this paper ~\cite{verbitskaia2024conversion}. We are using exactly the same approach for these stages, so we will focus on the other two stages.  

% \subsection{Binding Time Analysis (\bta)}

% Given modes of variables, \bta decides for each relation call, which annotation (Memo or Unfold) will be set to it. These annotations then serve as hints for \cpd. The aim of these annotations is to make \cpd more complete, while keeping it terminating. 

% Unfold annotation means that this call is safe to unfold and it forces \cpd to always unfold the call on Local Control phase. \bta tries to annotate Unfold as much calls as possible. Each time it annotates one more call as Unfold, TerminationChecker checks, if SLD-derivation with current annotations stops. If the termination is proven, then the annotation remains Unfold. Otherwise, it becomes Memo.

% \subsection{Conjunctive Partial Deduction (\cpd)}

% This article~\cite{de1999conjunctive} describes Conjunctive Partial Deduction well. We use similar approach, so here we just describe the general essence of the algorithm. The algorithm unrolls calls, much like what happens when executing a function, generating SLD-trees. These trees will then form a set of relations with their definitions.

% However, simple unfolding of some calls can produce infinite recursion. In order to prevent such situations, the algorithm consists of two parts:

% 1. \textit{Local control}: unfolding relations. To prevent infinite unfolding, algorithm checks, if the current node is an instance of some root (or uses other similar techniques), and stops unfolding in this case. In our algorithm, we can also force unfolding some calls, even if instanceCheck fails, using annotations. Some calls can be left unresolved. They, like successful substitutions, then form the body of the relation. 

% 2. \textit{Global control}: generating the set of relations, so that all calls in the definitions refer an existing relation. 

% \section{Examples}

% In this section, we provide some examples, which show improvements obtained using the Offline Partial Deduction approach compared to the conversion from the previous article and the conversion using Conjunctive Partial Deduction without annotations.

% \subsection{Relational sorting}

% The relation \lstinline{sort$^o$} checks the input list on emptiness. If list is not empty, it gets smallest element from the list, sort remaining elements and constructs a result.

% Figure~\ref{fig:sort} shows the implementation of sort relation \lstinline{sort$^o$}, the mode analysis result for mode  \lstinline{sort$^o$ x$^{f \to g}$ y$^{g\to g}$}, the deduction result for call \lstinline{sort$^o$ x ([Zero, Succ Zero, Succ (Succ Zero)])} and, finally, the result of functional conversion of residual program in \haskell.

% In this example we omitted definitions of such functions as \lstinline{minmax$^o$ a b min max}, \lstinline{le$^o$ a b flag} and \lstinline{gt$^o$ a b flag}. These functions are pretty simple and unfolded in our approach, so we have focused on the remaining functions.

% For \lstinline{smallest$^o$ l s l$_1$} Mode analysis derives \lstinline{smallest$^o$ l$^{f \to g}$ s$^{g \to g}$ l$_1$$^{g \to g}$}. Mode analysis avoids generators by rearranging clauses for this relations. It puts unification with left ground part on first place. Then follow two deterministic calls. And finally, unification with right ground part completes the function. Such rearranging allow then to mark all calls within the relation as Unfold.

% For \lstinline{sort$^o$ x$^{f \to g}$ y$^{g \to g}$} Mode analysis also changes the order of conjuncts, putting unification at the beginning and deterministic calls at the end.

% Because of rearranging clauses during Mode analysis,\bta can mark all calls as unfold and partial deduction will use this information for fully unfolding. As a result of \cpd we get only one definition that enumerates all answers with disjunction. This definition will be then translated into pretty simple function without generators.  

% \section{Evaluation}

% To show the advantages of our approach we compared it with approach of functional conversion used here ~\cite{verbitskaia2024conversion} and with approach, which don't use call annotations and run simply Online Partial Deduction. We ran these approaches on relations with some known parameters and then get functions which were generating remaining parameters. We measured time required for the resulting functions, written in \haskell, to generate suitable combinations of parameters. 

% \subsection{Relational sorting} 

%  As we have already seen the result of conversion of program ~\ref{fig:sort} just encounters all possible answers. That differs from the result, got by applying Online Partial Deduction, where resulting program is emulating the behaviour of the initial program, thus being ineffective.

%  Table ~\ref{tbl1:sort} shows comparison of the execution times of \lstinline{sort$^o$} running in backward direction. Here, we can see the improvement obtained by Offline Approach. The performance increased by 3 orders of magnitude for $n=5$.  However, it worth saying that translating query with result list length more than 5 gives enormous programs which can't be evaluated.

% \input{fig/relSortTime}    

% \subsection{Hanoi game}

% Hanoi game is a puzzle consisting of three rods and disks of various diameters. Initially all disks are placed on the left rod and their diameter decreases from top to bottom. The goal is to place all disks on the right rod. Player can only take one disk at a time and place it on the top of the rod, if it is empty or it's top disk is bigger than taken disk. 

%  In this example\footnote{Hanoi example \url{https://github.com/kajigor/uKanren_transformations/blob/BTA/test/resources/newSyntax/withTypeAnnotations/hanoi/hanoi_for_cpd.mk}.} we implemented program that checks, if finish state can be achieved from start state by following the given steps. We were interested in generating steps, when start and end state are given. 

%  Offline approach generates function for each configuration, thus producing exponential number of functions. However, as it is shown in ~\ref{tbl2:hanoi} it performs better on small inputs. 

% \input{fig/hanoiTime}

% \section{Conclusion and Future work}

% In this paper we described a semi-automatic functional conversion of a \mk relation with partially known input into a functional code. We applied the proposed solution to a set of examples, observing a slight improvements on almost all of examples and significant improvement on some relations. As a part of future work we want to improve annotations, produced by Binding Time Analysis, to extract more information, achieving more complete unfolding. 

% \nocite{*}
\bibliographystyle{eptcs}
\bibliography{generic}
\end{document}
